---
layout: post
title: 'Learning DS & Algos Finally'
categories: programming
permalink: /learning-ds-algos
description: Want to be a programmer? Not without this.
---

So I began programming in 2014. Self taught is what I liked to claim.
It felt good to claim this. I was accomplished in my work. I got hired
I did some work. It was good and fun. Welp, unbeknownst to me, many years
later and I still do not know how to program.

But you build applications and sell code? How can this be possible? Turns
out while you may not need a Comp Sci degree to learn how to code, you still
need to learn Data Structures and Algorithms to know how to use the computer
to write code efficiently. There is this magical little concept in computer
Science widely understood as Big O notation. It is the Time and Space complexity
that any given piece of code can scale at. If you are coding and your solution
has a complexity of polynomial time (2^n) then your solution is slow. And thats
not good. For problems in search this is a typical run time. Yup. But if you know
how to program using concepts from Data Structures and Algorithms, then guess
what, you can code up a solution that processes the data in a faster way
and drives down the time complexity. An ideal time complexity can be O(N).
Can you beat that? Probably not. Linear time is better than O(LogN) time
and better still than O(N^2) time.

But my code works, why do I need to know how to code for a different time complexity?
Because if you are coding an application or a software that is supposed to help
people, then it would behoove you to know how to make it work fast. How to make sure
that it will not fail. And to make sure that if the population of the earth were to
take interest in it, that they'd also be able to use your solution. It's less about
having code that just works and more about having the best code for the task. This
is why the DS and Algos course is present in the perennial Computer Science degree, because
this is science. It's a study.

I was accepted into a finishing school for Computer Science students on behest of my ability
to brute force a solution to 2 different problems that took x amount of minutes.
I am currently being trained by thoroughbred software engineers from Silicon Valley.
They are kicking my ass and I have not experienced what I would call a win yet. But
each and every day, I am white boarding. I am being cracked in the head with classic
computer science problems of lore: Towers of Hanoi, Sliding window problems, Quicksort,
Bank Robber problem. Each time, Im learning some new pattern of contorting my code
in such a way that I'd be able to shave down the time taken to process some large amount of
data - from O(N^2) to O(N) or even more cleverly to O(1). It's craziness. It's hard.
But I'm up to the challenge and when I'm done, I want more. Because I see how far this can
be taken.
